#!/usr/bin/env python
# -*-coding:utf-8 -*-
from sql.parser import parser
from sql.plan.planner import Planner
from sql.server.context import Context
from sql.kv.txn import Transaction
from sql.kv.dckv import DckvStore
from util.error import *
from mylog import logger
import time
from util.rwlock import RWLock
from collections import OrderedDict
from sql.parser.statement import SelectStmt, InsertStmt, DeleteStmt, UpdateStmt

SessionTimeout = 30 * 60  # 30 minutes
SessionMaxSize = 100

# for debug
# SessionTimeout = 60 
# SessionMaxSize = 10


class Session():
    def __init__(self, session_id, store=None, txn=None):
        '''
        @param store: DckvStore
        @param txn: Transaction
        '''
        self.session_id = session_id
        self.store = store
        self.txn = txn #: :type self.txt: Transaction
        self.parser = parser.Parser()
        self.planner = Planner()
        self.updatetime = time.time()
        self.autocommit = True
    
    # Execute a sql statement.                                        
    def Execute(self, ctx):
        '''
        @param ctx: Context
        @return: err in parser or executor
        '''
        # 1. sql string to statement
        err = self.parser.Parser(ctx)
        
        # 2. statement to executor
        self.planner.BuildExecutor(ctx)
        
        # 3. executor to txn
        if self.autocommit and self.IsDML(ctx):
            self.BeginTxn(ctx)
            err = ctx.executor.Execute()
            if err:
                self.RollbackTxn(ctx)
            else:
                err = self.CommitTxn(ctx)
        else:
            err = ctx.executor.Execute()
        ctx.SetErr(err)
        return err
                                  
    def execute(self, ctx):
        '''
        @type ctx: Context
        '''
        # 1. sql string to statement
        err = self.parser.Parser(ctx)
        if err:
            return err
        # 2. statement to executor
        self.planner.BuildExecutor(ctx)
        # 3. executor to txn
        err = ctx.executor.Execute()
        
        return err
    
    def IsDML(self, ctx):
        '''
        @param ctx: Context
        '''
        t = type(ctx.stmt)
        return t in (SelectStmt, InsertStmt, DeleteStmt, UpdateStmt)
    
    def SetAutoCommit(self, auto):
        self.autocommit = auto
    
    def BeginTxn(self, ctx):
        '''Begin txn
        @param ctx: Context
        '''
        if self.TxnValid():
            logger.warning('rollback un-commited txn, startTS=%s', self.txn.startTS)
            return ErrTxnAlreadyExists
        txn = self.store.Begin()
        self.txn = txn  # set by session
        return None
    
    def CommitTxn(self, ctx):
        '''Commit or close txn 
        @param ctx: Context
        '''
        if not self.TxnValid():
            return ErrInvalidTxn
        
        if self.txn.IsReadOnly():
            err = self.txn.Close()
        else:
            err = self.txn.Commit()
        
        return err
    
    
    def RollbackTxn(self, ctx=None):
        '''rollback or close txn 
        @param ctx: Context
        '''
        if not self.TxnValid():
            return ErrInvalidTxn

        err = self.txn.Rollback()
        return err
    
    def IsExpired(self):
        return time.time() > self.updatetime + SessionTimeout
    
    def TxnValid(self):
        return self.txn and self.txn.Valid()
    
    # GetClient gets a kv.Client.
    def GetClient(self):
        pass
    
    # InitTxnWithStartTS initializes a transaction with startTS.
    # It should be called right before we builds an executor.
    def InitTxnWithStartTS(self, startTS):
        pass

    # GetStore returns the store of session.
    def GetStore(self):  # kv.Storage
        return self.store

    # Flag of current status, such as autocommit.
    def Status(self):
        pass

    # LastInsertID is the last inserted auto_increment ID.                                     
    def LastInsertID(self):  # uint64
        pass
    
    # LastMessage is the info message that may be generated by last command                                      
    def LastMessage(self):  # string
        pass
    
    # Affected rows by latest executed stmt.
    def AffectedRows(self):  # uint64
        pass
    
    def Close(self):
        pass
    
    def Auth(self, user, auth, salt):  # bool
        pass

    # FieldList returns fields list of a table.
    def FieldList(self, tableName):  # (fields []*ast.ResultField, err error)
        pass
   
    
class SessionPool():
    '''LRU Cache for Sessions
    '''

    def __init__(self):
        self.lock = RWLock()
        self.sessions = OrderedDict()
        
    def Get(self, session_id):
        self.lock.Lock()
        session = None
        if session_id in self.sessions:
            # make the session to the last postion
            session = self.sessions[session_id]
            del self.sessions[session_id]
            self.sessions[session_id] = session
        self.lock.UnLock()
        return session
    
    def Set(self, session):
        '''
        @param session: Session
        @return: ErrSessionMaxSize
        '''
        self.lock.Lock()
        if session.session_id in self.sessions:
            del self.sessions[session.session_id]
        elif SessionMaxSize <= len(self.sessions):
            # assert not empty
            assert self.sessions
            # get first element if max size
            for sid, s in self.sessions.iteritems():
                if s.IsExpired():
                    logger.debug("pop expired session, id=%d", sid)
                    self.sessions.pop(sid)
                    break
                else:
                    logger.debug("max session num")
                    self.lock.UnLock()
                    return ErrSessionMaxSize
        # update the session to the last of the sessions
        self.sessions[session.session_id] = session
        self.lock.UnLock()
        return None
    
    def Delete(self, session_id):
        self.lock.Lock()
        if session_id in self.sessions:
            del self.sessions[session_id]
        self.lock.UnLock()
        
    def IsValid(self, session_id):
        return session_id in self.sessions
